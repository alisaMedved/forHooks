import React, {useCallback} from 'react';



const ChildComponent = ({handleClick}) => {
    return (
        <div>
            <button onClick={handleClick}>Тестовая кнопка</button>
        </div>
    );
};

export const Test = () => {
    const handleClick = useCallback(() => {
        console.log("meow");
    }, []);
    return (
        <div>
            <ChildComponent handleClick={handleClick} />
        </div>
    );
};

// но пчм мы все так не пишем?

// 1) это имеет смысл если компонент ChildComponent прям обернут в memo
// во избежание лишних рендеров. то же самое и про значение пропса, обернутое в useMemo

//2) сейчас представлен простой пример - а вдруг в зависимостях к useCallback запутаться можно
// и одну случайно не указать - все все придется ручками регулировать рендеры - и потому все все зависимости надо аккуратно прописать

//3) если все зависимости useCallback меняются при каждом рендере то и смысла тогда в useCallback равно как и в useMemo нет
//пример - конвенртатор валют
// вбили в инпут долларов и в остальных дивках отобразилилсь рубли гривны и т д.
// ну а что если единственным фактором вызывающем перендер - это правки в инпут доллара - тогда и функцию рассчета конвертации
// мемоизировать глупо
// 3.1) а если мы прокидываем результаты вычисления конвертатора в дочерние объекты ? Да тогда стоит useMemo лишний перендер
// компонента дороже чем вызов useMemo - но ведь и там можно вместо этого обернуть компонет дочерний в memo и все
// и никакого useMemo


//useRef мы используем для того чтобы не терять ссылку на DOM элемент при обновлениях компонента (например setState сработал);
// хранить в useRef данные все таки плохая идея
// а как насчет массива ссылок на DOM элементы?





